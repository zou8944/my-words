---
created_at: 2019-09-13 11:41:06.0
updated_at: 2021-02-16 23:26:14.682
slug: recommendation-system-recommend-based-on-user-behaviour
tags:
- 推荐
---

# 基于用户行为的理由

## 让用户直接说不就好了吗

本文标题是利用用户的数据行为, 是根据用户的实际动作进行演算的方法, 那为什么不利用用户语言进行演算呢? 最大的原因就是用户也说不清楚自己到底喜欢什么, 而用户的实际行为往往能够暴露其真实想法, 有些想法用户自己可能都还没有意识到.
<!-- more -->

## 经典的例子 - 尿布和啤酒

一个数据挖掘的经典案例: 一个超市人员发现很多人会同时购买啤酒和尿布, 后来他们认为这是因为很多妇女要在家照顾孩子, 就让自己的丈夫去买尿布, 而丈夫买尿布时还不忘买一下自己喜欢的啤酒, 于是二者产生了联系. 然后超市将这两个商品摆在临近的货架上, 发现销售量增长了.

从中可以看到用户的行为数据中蕴含了很多不是那么显而易见的规律, 而我么的个性化推荐算法的任务就是通过计算机去发现这些规律, 从而为产品的设计提供指导, 提升用户体验.

# 协同过滤

协同过滤算法就是指用户可以齐心协力, 通过不断与网站互动, 使自己的推荐列表能够不断过滤掉不感兴趣的物品, 变得越来越个性化, 这也和亚马逊的为每个用户打造一个属于自己的商店的思想不谋而合.

仅基于用户行为数据设计的推荐算法称为协同过滤算法. 在学术界对这方面有深入的研究, 提出来多种方法, 比如基于邻域的算法, 隐语义模型, 基于图的随机游走算法等. 本文仅介绍两种基于邻域的算法.

- 基于用户的协同过滤算法
- 基于物品的协同过滤算法

# 收集用户的行为

有多种方式收集用户的行为

- 打日志
- 收集用户都商品的喜好程度
- 记录用户所有访问记录等

在设计算法前, 需要对收集到的数据进行分析.

# 基于用户的协同过滤算法

基于用户的协同过滤算法主要包含如下两个步骤

- 找到和目标用户相似的用户集合
- 找到这个用户集合中用户喜欢的, 且目标用户没有听说过的物品推荐给用户

即先找同类用户, 再找同类用户喜欢的商品

## 用户相似度的计算

该算法的难点在于寻找相似的用户集合, 意味着需要对每一个目标用户意外的用户和目标用户进行相似度计算, 取最高的那一部分, 最常规的方法是使用余弦相似度进行计算. 但这样会造成某些用户与目标用户原本一点关系都没有还需要计算一次的浪费. 

为了解决这个问题, 可以在物品中添加用户id的冗余数据, 通过对所有物品的用户id组件稀疏矩阵, 只针对有联系的用户进行计算.

## 目标用户对某一物品感兴趣程度的计算

就是所有与目标用户相似的用户对该目标物品感兴趣的程度的累加. 即越多相似用户喜欢目标物品, 则用户可能越感兴趣

## 热门商品的处理

算到最后会发现, 所有用户都看过或喜欢热门商品, 但目标用户不一定喜欢该热门商品. 比如所有人都买过新华字典, 但这并不能说明他们兴趣相似, 所以推荐新华字典并不是一个好的选择. 换句话说, 两个用户对冷门物品采取过同样的行为更能说明他们的兴趣相似度. 因此计算时应该去除或将其热门商品的权重.

# 基于物品的协同过滤算法

该算法是目前业界使用最多的算法. 无论是亚马逊, 还是Netflix, Youtube, 其推荐算法的基础都是该算法.

## 基于用户的协同过滤算法的问题

随着用户的增长, 用户相似度矩阵会呈平方增长, 而当今互联网用户量及其庞大, 因此带来了用户相似度计算的浪费.

针对这个问题, 亚马逊提出了基于物品的协同过滤算法. 它主要通过分析用户的行为记录计算物品之间的相似度.

## 基于物品的协同过滤算法

该算法主要分为两步

- 计算物品之间的相似度
- 根据物品相似度和用户的历史行为给用户生成推荐列表

## 物品相似度计算

物品i和物品j的相似度, 可以用: 喜欢i的用户中, 喜欢j的用户所占比例 进行计算. 可以想见. 物品相似度的计算, 就是计算物品被很多用户共同喜欢的程度. 

是根据用户对物品的历史记录进行计算, 即一个用户对应购买过的多个物品. 这一点恰好和基于用户的协同算法想法( 它是一个物品存储购买过它的用户冗余数据 )

## 生成推荐列表

计算出物品相似度, 从高到低排列, 剔除用户购买历史, 即为推荐列表.

## 去除活跃用户的影响

活跃用户会造成任何两个物品都存在相似度, 于是物品相似矩阵编程稠密矩阵, 浪费大量的算力. 一个例子就是如果某个书店在当当购买了所有书籍, 把它当成一个常规用户的话, 显然当当的所有书都有一定的相似度了, 显然这是不对的. 因此计算中需要考虑去除活跃用户的影响.

# 两种领域算法的对比

| 项目     | 基于用户的协同过滤算法                                       | 基于物品的协同过滤算法                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 性能     | 适用于用户较少场合, 用户过多造成计算用户相似度矩阵过大       | 适用于物品数量明显小于用户数的场合, 物品过多会造成物品相似度矩阵过大 |
| 场景     | 时效性较强, 但用户个性化不太明显的场合                       | 长尾物品丰富, 用户个性化需求强烈的领域                       |
| 实时性   | 用户新行为不一定造成推荐结果立即变化                         | 用户新行为一定造成结果立即变化                               |
| 冷启动   | 新用户对很少物品产生行为时, 不能立即进行个性化推荐; 新物品上线后只要有行为就能被推荐给兴趣相似的用户 | 相反, 这里新用户只要有一个行为就可以推荐; 新物品上线后要有足够的访问量才能被推荐出去 |
| 推荐解释 | 难以提供给用户信服的推荐理由                                 | 利用用户的历史行为做推荐解释, 比较令人信服                   |

# 说明

本文是基础介绍性质的文章, 为能够快速阅读, 并没有任何公式运算, 上述所讲述算法也仅是基本思想, 带大家认识推荐算法. 具体算法需要参考更多文章和书籍.