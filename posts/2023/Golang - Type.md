> 假设要自己写的代码中需要序列化变量，必然需要了解类型的判断。类似的场景还有很多。

## 获取类型的方式

### x.(type)

这又被称之为类型断言，可以用于类型判断和类型转换。

- 用于类型判断
- 用于类型转换

### reflect.TypeOf(x)



### reflect.ValueOf(x).Kind()



### fmt.Printf("%T", x)



## 类型转换的几种方式

### T(x)

- 并非所有类型转换都能成功，通过如下检查，类型转换就能成功

  

> 此类类型转换只发生在编译阶段，运行时不会发生。



## 反射中的类型

- reflect.Kind和reflect.Type有什么区别？

## Tips



## 一些问题

- 类型断言的原理是什么？是反射的语法糖吗？

  

- 基本类型互转，高地容量类型之间互转会发生内存拷贝吗？

  

- 字符串转字节切换会发生内存拷贝吗？为什么？

  我们可以做个实验

  ```go
  aa := []byte("string")
  bb := aa
  fmt.Printf("%b\n", aa)
  fmt.Printf("%b\n", bb)
  bb[2] = 'a'
  fmt.Printf("%b\n", aa)
  fmt.Printf("%b\n", bb)
  ```

  输出如下。修改bb时，aa的值也发生了变化，说明赋值aa给bb时，拷贝的是指针

  ```shell
  [1110011 1110100 1110010 1101001 1101110 1100111]
  [1110011 1110100 1110010 1101001 1101110 1100111]
  [1110011 1110100 1100001 1101001 1101110 1100111]
  [1110011 1110100 1100001 1101001 1101110 1100111]
  ```

  再看

  ```go
  a := "string"
  b := []byte(a)
  fmt.Printf("%s\n", a)
  fmt.Printf("%b\n", b)
  b[2] = 'a'
  fmt.Printf("%s\n", a)
  fmt.Printf("%b\n", b)
  ```

  输出如下。修改b时，a并没有发生变化。转换为切片时，拷贝了内存，然后将新内存的地址赋给了b。

  ```shell
  string
  [1110011 1110100 1110010 1101001 1101110 1100111]
  string
  [1110011 1110100 1100001 1101001 1101110 1100111]
  ```

  如果我们使用unsafe包，据说这样就不会内存复制。但是无法验证，因为此时去修改bbb的值会报错🤔

  ```go
  aaa := "string"
  paaa := *(*reflect.StringHeader)(unsafe.Pointer(&aaa))
  bbb := *(*[]byte)(unsafe.Pointer(&paaa))
  ```

  不过需要注意的是，第二个例子带来的内存拷贝并非是类型转换引起的，而是因为string不可变。

- unsafe.Pointer 为什么这么神奇？

- binary.Write() 不支持int类型，为什么？